#if 0

typedef struct kTimRing
{
    UINT32   head;
    UINT32   tail;
    UINT32   size;
    BOOL     init;
    K_TIMER  timers[N_RELOAD_TIMERS];
}TIM_RING;

static TIM_RING appTimRing = {0};

void kTimRingInit()
{
    appTimRing.head=0;
    appTimRing.tail=0;
    appTimRing.size=0;
    appTimRing.init=TRUE;

}

K_ERR kTimRingAdd(K_TIMER** timerPPtr)
{
    if (appTimRing.init == FALSE)
    {

        kTimRingInit();
    }
    UINT32 slot = appTimRing.tail;

    kMemCpy(&(appTimRing.timers[slot]), *timerPPtr, sizeof(K_TIMER));
    appTimRing.tail = (appTimRing.tail + 1U) % N_RELOAD_TIMERS;
    appTimRing.size = (appTimRing.size + 1U) % N_RELOAD_TIMERS;
    return K_SUCCESS;
}

K_TIMER* kTimRingGet()
{
    K_TIMER* retPtr=NULL;
    if (appTimRing.size==0)
        assert(0);

    retPtr = &appTimRing.timers[appTimRing.head];
    appTimRing.head = (appTimRing.head + 1) % N_RELOAD_TIMERS;
    appTimRing.size = (appTimRing.size - 1U) % N_RELOAD_TIMERS;
    return retPtr;
}

static
K_ERR kTmrListAdd(K_TIMER** const selfPtr, STRING timerName, ADDR objPtr,
        K_TICK ticks, VOID (*calloutFPtr)(ADDR), ADDR cbArgsPtr,
        BOOL autoReload);


K_ERR kTmrPoolInit(VOID)
{

    kSemaInit(&timerSemaCnt, N_TIMERS);
    return kMemInit(&timerMem, timerPool, TIMER_SIZE, N_TIMERS);
}

K_ERR kTimerInit(STRING timerName, VOID (*calloutFPtr)(ADDR), K_TICK timeCount,
        BOOL autoReload)
{
    K_CR_AREA;
    K_ENTER_CR;
    if (autoReload==TRUE)
    {
        assert(kTmrListAdd(&dTimReloadList, timerName, NULL, timeCount, \
            calloutFPtr, NULL, autoReload) == 0);
        K_EXIT_CR;
        return K_SUCCESS;

    }
    else
    {
        assert(kTmrListAdd(&dTimOneShotList, timerName, NULL, timeCount, \
                calloutFPtr, NULL, autoReload) == 0);
        K_EXIT_CR;
        return K_ERROR;

    }
}

static K_PID kGetTaskUserID(K_TCB* tcb)
{
    K_PID retVal = tcb->uPid;
    return retVal;
}


static BOOL kPrio1Higher(K_PRIO prio1, K_PRIO prio2)
{
    if (prio1 < prio2)
    {
        return true;
    }
    return false;
}
static K_PID kGetTaskUserID(K_TCB* tcb)
{
    K_PID retVal = tcb->uPid;
    return retVal;
}


static BOOL kPrio1Higher(K_PRIO prio1, K_PRIO prio2)
{
    if (prio1 < prio2)
    {
        return true;
    }
    return false;
}

void kSignalFromISR(K_PID taskID)
{

    K_PID pid = kGetTaskPID(taskID);
    if (tcbs[pid].status == PENDING)
    {
        K_TCB* tcbGotPtr=&tcbs[pid];
        kTCBQRem(&waitingQueue[tcbGotPtr->priority], &tcbGotPtr);
        kTCBQEnq(&readyQueue[tcbGotPtr->priority], tcbGotPtr);
        tcbGotPtr->status=READY;
    }
    return;
}

#endif