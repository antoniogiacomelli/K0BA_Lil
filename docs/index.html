<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<title>K0BA Documentation (v0.3.1L)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="docbook toc2 toc-left data-line-1">
<div id="header">
<h1><strong>K0BA  Documentation</strong> (v0.3.1L)</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#process_threads_and_tasks"><strong>Process, Threads and Tasks</strong></a></li>
<li><a href="#core_mechanisms"><strong>Core Mechanisms</strong></a>
<ul class="sectlevel1">
<li><a href="#o1_scheduler">1. O(1) scheduler</a>
<ul class="sectlevel2">
<li><a href="#data_structures">1.1. Data Structures</a></li>
<li><a href="#the_scheduling_algorithm">1.2. The scheduling algorithm</a></li>
<li><a href="#scheduler_determinism">1.3. Scheduler Determinism</a></li>
<li><a href="#common_scheduling_pitfalls">1.4. Common scheduling pitfalls</a></li>
</ul>
</li>
<li><a href="#timers">2. Timers</a>
<ul class="sectlevel2">
<li><a href="#task_delays">2.1. Task Delays</a></li>
<li><a href="#application_timers">2.2. Application Timers</a></li>
</ul>
</li>
<li><a href="#memory_allocator">3. Memory Allocator</a>
<ul class="sectlevel2">
<li><a href="#memory_allocator_determinism">3.1. Memory Allocator Determinism</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#inter_task_synchronisation_and_communication_itc"><strong>Inter-task synchronisation and communication (ITC)</strong></a>
<ul class="sectlevel1">
<li><a href="#direct_signals">1. Direct Signals</a></li>
<li><a href="#counter_semaphores">2. Counter Semaphores</a></li>
<li><a href="#mutex_semaphores">3. Mutex Semaphores</a></li>
<li><a href="#events_sleepwake">4. Events (Sleep/Wake)</a></li>
<li><a href="#remarks_on_synchronisation_services">5. Remarks on synchronisation services</a>
<ul class="sectlevel2">
<li><a href="#installed_callbacks_for_signals">5.1. Installed callbacks for signals</a></li>
<li><a href="#time_out_on_blocking_primitives">5.2. Time-out on blocking primitives</a></li>
<li><a href="#event_groups_multi_condition_synchronisation">5.3. Event Groups (multi-condition synchronisation)</a></li>
</ul>
</li>
<li><a href="#mailbox">6. Mailbox</a>
<ul class="sectlevel2">
<li><a href="#sending_receiving">6.1. Sending-receiving</a></li>
<li><a href="#asynchronous_mailboxes_methods">6.2. Asynchronous mailboxes methods</a></li>
</ul>
</li>
<li><a href="#message_queue">7. Message Queue</a></li>
<li><a href="#pump_drop_messages">8. Pump-Drop Messages</a></li>
</ul>
</li>
<li><a href="#usage_patterns"><strong>Usage Patterns</strong></a>
<ul class="sectlevel1">
<li><a href="#monitor_0_barrier">1. Monitor #0 (Barrier)</a></li>
<li><a href="#monitor_1_turnstile">2. Monitor #1 (Turnstile)</a></li>
<li><a href="#multi_condition_notification_0">3. Multi-condition Notification #0</a></li>
<li><a href="#multi_condition_notification_1">4. Multi-condition Notification #1</a></li>
<li><a href="#extended_rendez_vous_0">5. Extended rendez-vous #0</a></li>
<li><a href="#extended_rendez_vous_1">6. Extended rendez-vous #1</a></li>
<li><a href="#extended_rendez_vous_2">7. Extended rendez-vous #2</a></li>
<li><a href="#queueing_pattern_0">8. Queueing Pattern #0</a></li>
<li><a href="#queueing_pattern_1_active_object">9. Queueing Pattern #1 (Active Object)</a></li>
</ul>
</li>
<li><a href="#the_road_ahead">The road ahead</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="exampleblock data-line-11">
<div class="content">
<div class="admonitionblock note data-line-13">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is a high-level system description. For API details look at <code>kapi.h</code>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<h1 id="process_threads_and_tasks" class="sect0 data-line-16"><strong>Process, Threads and Tasks</strong></h1>
<div class="paragraph data-line-18">
<p><strong><em>K0BA Lil'</em></strong> (a.k.a <em>K0</em>) is flat: there is no <em>user-space</em>, and therefore <em>no system calls</em>. Low-end MCUs based on the supported architecture (<em>ARMv7M</em>) often do not come with an MPU - so privilege levels are limited to the CPU scope: instructions and registers. This level of safety does not compensate for the overhead of splitting privileges - namely, the cost of system calls.</p>
</div>
<div class="imageblock data-line-20">
<div class="content">
<img src="images/images/layeredkernel.png" alt="layeredkernel">
</div>
</div>
<div class="paragraph data-line-21">
<p><em>Architectural depiction</em></p>
</div>
<div class="paragraph data-line-23">
<p>A process is composed by an execution image and an address space. A thread is a logical sequence of instructions. A process can have a single or multiple threads within the same address space.</p>
</div>
<div class="paragraph data-line-25">
<p>On the embedded realm (probably because we lack a better abstraction) we use <em>multithreading</em> to fine-tune our load balance, and therefore the responsiveness to achieve real-time.</p>
</div>
<div class="paragraph data-line-27">
<p>So, the K0 multitasking engine is wired to a single process on a single address space - as the majority of small kernels you see around.</p>
</div>
<div class="paragraph data-line-29">
<p>This is an arrangement: instead of of having a single super-loop, we have many - each one running on its own execution stack.</p>
</div>
<div class="paragraph data-line-31">
<p>This arrangement yields an operating system entitity to handle - an <em>execution unit</em>: in K0 we name it a <em>Task</em> (the terms task and thread are used interchangeably on this document.)</p>
</div>
<h1 id="core_mechanisms" class="sect0 data-line-33"><strong>Core Mechanisms</strong></h1>
<div class="paragraph data-line-35">
<p>In this section a high-level description of the kernel core mechanisms is provided. These mechanisms are always present: scheduler, timers and memory allocator.</p>
</div>
<div class="sect1 data-line-37">
<h2 id="o1_scheduler">1. O(1) scheduler</h2>
<div class="sectionbody">
<div class="paragraph data-line-39">
<p>K0 employs a priority rate-monotonic scheduler. A higher priority task always preempts a low priority task. The algorithm is supposed to work up to a load of around 70%.</p>
</div>
<div class="paragraph data-line-41">
<p>Tasks with shorter periods ideally are assigned to higher priorities.</p>
</div>
<div class="paragraph data-line-43">
<p>The scheduler supports 255 tasks and 32 priorities. Remarkably, it is an O(1) scheduler: no matter the number of tasks to choose from, the scheduler will always spend the same amount of (logical) time.</p>
</div>
<div class="sect2 data-line-45">
<h3 id="data_structures">1.1. Data Structures</h3>
<div class="sect3 data-line-47">
<h4 id="task_control_block">1.1.1. Task Control Block</h4>
<div class="paragraph data-line-49">
<p>Threads are represented as Tasks. Every task is associated to a Task Control Block structure. This is a record for stack, resources and time management:</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-53">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Task Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Task name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Saved Stack Pointer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stack Adddress</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stack Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Status (ready, running, sending…​)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assigned Priority</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current Priority</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User Assigned ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kernel Assigned ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time-Slice</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remaining time-slice</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Last wake-time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flags: run-to-completion, timed-out, yielded</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pending resources: semaphores, mutexes, timers, message passing, etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Monitoring: dispatch counter, lost signals, number of preemptions, preempted by</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aggregated list node</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-73">
<p>Tasks are static - they cannot be created on runtime, to be destroyed, to fork or join.</p>
</div>
<div class="paragraph data-line-75">
<p>On practice, tasks are either running or waiting for its turn to run. When there is no blocking condition, we say a task is <code>READY</code>  - it is just waiting for the scheduler. When there is a blocking condition the task is <code>WAITING</code>. A tasks needs to be READY to be picked up by the kernel scheduler and switch to <code>RUNNING</code>.</p>
</div>
<div class="imageblock data-line-78">
<div class="content">
<img src="images/images/taskstates.png" alt="taskstates">
</div>
</div>
<div class="paragraph data-line-81">
<p>We extend the WAITING state logically as:</p>
</div>
<div class="ulist data-line-83">
<ul>
<li class="data-line-83">
<p>PENDING : the task suspended itself waiting for a  direct signal.</p>
</li>
<li class="data-line-85">
<p>SUSPENDED: the task has been suspended by another task, and will switch to <em>READY</em> when signalled.</p>
</li>
<li class="data-line-87">
<p>SLEEPING: a task is normally sleeping for an <em>event</em>. This is a broad concept we explore a bit later.</p>
</li>
<li class="data-line-89">
<p>BLOCKED: a task is blocked on a critical region, when trying to access a busy resource.</p>
</li>
<li class="data-line-91">
<p>SENDING/RECEIVING: same as blocked, but the busy resource is a kernel object for message passing (or similar) mechanism.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-94">
<h4 id="task_queues">1.1.2. Task Queues</h4>
<div class="paragraph data-line-95">
<p>The backbone of the queues where tasks will wait for its turn to run is a circular doubly linked list: removing any item from a doubly list takes O(1) (provided we don’t need to search the item). As the kernel is aware of each task’s address, adding and removing is always O(1). Singly linked lists, can’t achieve O(1) for removal in any case.</p>
</div>
<div class="paragraph data-line-97">
<p>A circular doubly linked-list ADT is employed:</p>
</div>
<div class="listingblock data-line-100">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">       HEAD                                          TAIL
	   _____     _____     _____     _____           _____
	  |     |--&gt;|     |--&gt;|     |--&gt;|     |--&gt;   &lt;--|     |
	  |DUMMY|   |  H  |   | H+1 |   | H+2 |  . . .  |  T  |
	&lt;-|_____|&lt;--|_____|&lt;--|_____|&lt;--|_____|         |_____|--&gt;
	|________________________________________________________|


	 - INITIALISE

	 The list is initialised by declaring a node, and assigning its previous
	 and next pointers to itself. This is the anchored reference.
		      _____
		   __|__   |
		  |     |--&gt;
		  |DUMMY|
		&lt;-|_____|
		|____|


	 - INSERT AFTER

		When list is empty we are inserting the head (that is also the tail).
		If not empty:
		 To insert on the head, reference node is the dummy.
		 To insert on the tail, reference node is the current tail
		 (dummy's previous node).
		     _____     _____     _____
		    | ref |-&gt; | new |-&gt; | old |-&gt;
		 . .|     |   |next |   | next| . . .
		  &lt;-|_____| &lt;-|_____| &lt;-|_____|

	 - REMOVE A NODE

	  	 To remove a node we "cut off" its next and previous links, rearranging
	  	 as: node.prev.next = node.next; node.next.prev = node.prev;

		    	         _______________
		         _____  |  _____     ___|_
		        |     |-&gt; |     x   |     |-&gt;
		   . . .|prev |   |node |   | next| . . .
		      &lt;-|_____|   x_____| &lt;-|_____|
			   |______________|


	   To remove the head, we remove the dummy's next node
	   To remove the tail, we remove the dummy's previous node
	   In both cases, the list adjusts itself</code></pre>
</div>
</div>
<div class="paragraph data-line-152">
<p>Thus, comes another design choice towards achieving O(1). The global ready queue is a table of FIFO queues—each queue dedicated to a priority—and not a single ordered queue. So, enqueuing a ready task is always O(1). If tasks were placed on a single ready queue, the time complexity would be O(n), given the sorting needed.</p>
</div>
</div>
</div>
<div class="sect2 data-line-154">
<h3 id="the_scheduling_algorithm">1.2. The scheduling algorithm</h3>
<div class="paragraph data-line-156">
<p>It goes like this: as the ready queue table is indexed by priority - the index 0 points to the queue of ready tasks with priority 0, and so forth, and there are 32 possible priorities - a 32-bit integer can represent the state of the ready queue table. It is a BITMAP:</p>
</div>
<div class="listingblock data-line-158">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">The BITMAP computation: ((1a) OR (1b)) AND (2), s.t.:

(1a) Every Time a task is readied, update: BITMAP |= (1U &lt;&lt; task-&gt;priority );
(1b) Every Time an empty READY QUEUE becomes non-empty, update: BITMAP |= (1U &lt;&lt; queueIndex)
(2): Every Time READY QUEUE becomes empty, update: BITMAP &amp;= ~(1U &lt;&lt; queueIndex);
EXAMPLE:

  Ready Queue Index :     (6)5 4 3 2 1 0
          Not empty :      1 1 1 0 0 1 0
                           -------------&gt;
                 (LOW)  Effective Priority  (HIGH)
In this case, the scenario is a system with 7 priority task levels. Queues with priorities 6, 5, 4, and 1 are not empty.</code></pre>
</div>
</div>
<div class="paragraph data-line-176">
<p>The idle task priority is assigned by the kernel, during initialisation taking into account all priorities the system programmer has defined. Unless user-tasks are occupying all 32 piorities, the Idle Task is treated as an ordinary lowest-priority and has a position in the queue. If not, the idle task on practice will have no queue position, and will be selected when the BITMAP is 0. In the above bitmap, the idletask is in readyQueue[6] .</p>
</div>
<div class="paragraph data-line-178">
<p>Given this mask, we know that we shall start inspecting on the LSBit and stop when the first 1 is found. There are uncountable manners of doing this. The approach I chose is:</p>
</div>
<div class="paragraph data-line-180">
<p>(1) Isolate the rightmost '1':</p>
</div>
<div class="listingblock data-line-182">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">RBITMAP = BITMAP &amp; -BITMAP. (- is the bitwise operator for two's complement: ~BITMAP + 1) `</code></pre>
</div>
</div>
<div class="paragraph data-line-186">
<p>In this case:</p>
</div>
<div class="listingblock data-line-188">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">                           [31]       [0]  :  Bit Position
                             0...1110010   :  BITMAP
                             1...0001110   : -BITMAP
                            =============
                             0...0000010   :  RBITMAP
                                     [1]</code></pre>
</div>
</div>
<div class="paragraph data-line-198">
<p>The rationale here is that, for a number N, its 2’s complement -N, flips all bits - except the rightmost '1' (by adding '1') . Then, N &amp; -N results in a word with all 0-bits except for the less significant '1'.</p>
</div>
<div class="paragraph data-line-200">
<p>(2) Extract rightmost '1' position:</p>
</div>
<div class="paragraph data-line-202">
<p>Within GCC, the _builtin_ctz() function does the trick: it returns the number of _trailing 0-bits within an integer, starting from the LSbit. The number of 'trailing zeroes' equals the position where the first '1' is found, that is also the ready queue index (and hence the priority) of the next task to be dispatched.</p>
</div>
<div class="paragraph data-line-204">
<p>Using ARMv7M instructions, a possible solution is to use the CLZ (count lead zeros):</p>
</div>
<div class="listingblock data-line-205">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">.global __getReadyPrio
.type __getReadyPrio, %function
.thumb_func
__getReadyPrio:
CLZ  R12, R0
MOV  R0, R12
NEG  R0, R0
ADD  R0, #31

BX LR</code></pre>
</div>
</div>
<div class="paragraph data-line-218">
<p>Thus, we subtract 31 from the number of leading zeroes, and get the index.</p>
</div>
<div class="paragraph data-line-220">
<p>The source code in K0BA looks like:</p>
</div>
<div class="listingblock data-line-222">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">static inline PRIO kCalcNextTaskPrio_()
{
    if (readyQBitMask == 0U)
    {
        return (idleTaskPrio);
    }
    readyQRightMask = readyQBitMask &amp; -readyQBitMask;
    PRIO prioVal = (PRIO) (__getReadyPrio(readyQRightMask));
    return (prioVal);
    // or GCC builtin (more portable)
    //return (PRIO)(__builtin_ctz(readyQRightMask));
}

VOID kSchSwtch(VOID)
{
	nextTaskPrio = calcNextTaskPrio_();
	K_TCB* nextRunPtr = NULL;
	K_ERR err = kTCBQDeq( &amp;readyQueue[nextTaskPrio], &amp;nextRunPtr);
	if ((nextRunPtr == NULL) || (err != K_SUCCESS))
	{
	    kErrHandler(FAULT_READYQ);
	}
	runPtr = nextRunPtr;
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-251">
<h3 id="scheduler_determinism">1.3. Scheduler Determinism</h3>
<div class="sect3 data-line-253">
<h4 id="preemptive_scheduling">1.3.1. Preemptive scheduling</h4>
<div class="paragraph data-line-254">
<p>This is a simple test to establish some evidence the scheduler obeys the preemption criteria: a higher priority task always preempts a lower priority task.</p>
</div>
<div class="paragraph data-line-256">
<p>Task1, 2, 3, 4 are in descending order of priority. If the scheduler is well-behaved, we shall see counters differing by "1".</p>
</div>
<div class="listingblock data-line-258">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">volatile UINT32 counter1;
volatile UINT32 counter2;
volatile UINT32 counter3;
volatile UINT32 counter4;

VOID Task1(VOID)
{
	while(1)
	{
		counter1++;
		kPend();
	}
}

VOID Task2(VOID)
{
	while(1)
	{
		counter2++;
		kSignal(1); /* shall immediately be preempted by task1 */
		kPend();    /* suspends again */

	}
}


VOID Task3(VOID)
{
	while(1)
	{
		counter3++;
		kSignal(2);  /* shall immediately be preempted by task2 */
		kPend();     /* suspends again */
	}


}

VOID Task4(VOID)
{
	while(1)
	{
	    counter4++;
	    kSignal(3); /* shall immediately be preempted by task3 */
                        /* as the lowest priority task it will only be resumed
                           after all higher priority tasks are suspended */
	}

}</code></pre>
</div>
</div>
<div class="paragraph data-line-312">
<p>This is the output after some time running:</p>
</div>
<div class="imageblock data-line-314">
<div class="content">
<img src="images/images/signaldet.png" alt="signaldet">
</div>
</div>
<div class="paragraph data-line-316">
<p>In the above example, we use direct signals. For semaphores:</p>
</div>
<div class="listingblock data-line-318">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">K_SEMA sema1;
K_SEMA sema2;
K_SEMA sema3;
K_SEMA sema4;
volatile UINT32 counter1, counter2, counter3, counter4; /*dont code like this*/
VOID kApplicationInit(VOID)
{
	kSemaInit(&amp;sema1, 0);
	kSemaInit(&amp;sema2, 0);
	kSemaInit(&amp;sema3, 0);
	kSemaInit(&amp;sema4, 0);
	counter1=counter2=counter3=counter4=0; /*dont code like this*/
}

VOID Task1(VOID)
{

	while (1)
	{
		counter1++;
		kSemaWait(&amp;sema1, K_WAIT_FOREVER);
	}
}

VOID Task2(VOID)
{

	while (1)
	{
		counter2++;
		kSemaSignal(&amp;sema1);
		kSemaWait(&amp;sema2, K_WAIT_FOREVER);
	}
}

VOID Task3(VOID)
{
	while (1)
	{
		counter3++;
		kSemaSignal(&amp;sema2);
		kSemaWait(&amp;sema3, K_WAIT_FOREVER);
	}
}

VOID Task4(VOID)
{
	while (1)
	{

		counter4++;
		kSemaSignal(&amp;sema3);
	}
}</code></pre>
</div>
</div>
<div class="imageblock data-line-376">
<div class="content">
<img src="images/images/semadet.png" alt="semadet">
</div>
</div>
<div class="paragraph data-line-378">
<p>Here tick is running @ 1ms (1KHz)</p>
</div>
</div>
<div class="sect3 data-line-380">
<h4 id="cooperative_scheduling">1.3.2. Cooperative scheduling</h4>
<div class="paragraph data-line-382">
<p>If we set all tasks at the same priority and every tasks yields the processsor, they will run on a round-robin fashion, one after another. So, every time we pause chances are we will be in the "somehwere in the middle" of a <em>round</em>.</p>
</div>
<div class="paragraph data-line-384">
<p>If every task increases a counter before yielding what we expect to see is a set of counters on a fashion {K, K, K, K-1, K-1, K-1}. Importantly a counter will not offset another by more than 1 if the scheduler is deterministic.</p>
</div>
<div class="paragraph data-line-386">
<p>On the code below all tasks have the same priority.</p>
</div>
<div class="listingblock data-line-388">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">VOID Task1(VOID)
{

	while (1)
	{
		count1 += 1;
		kYield();
	}
}

VOID Task2(VOID)
{
	while (1)
	{
		count2 += 1;
		kYield();
	}
}

VOID Task3(VOID)
{
	while (1)
	{
		count3 += 1;
		kYield();
	}

}

VOID Task4(VOID)
{
	while (1)
	{
		count4 += 1;
		kYield();
	}

}

VOID Task5(VOID)
{
	while (1)
	{
		count5 += 1;
		kYield();
	}

}</code></pre>
</div>
</div>
<div class="paragraph data-line-438">
<p>The picture below show the results after ~ 13 million rounds.</p>
</div>
<div class="imageblock data-line-440">
<div class="content">
<img src="images/images/determrr.png" alt="determrr">
</div>
</div>
</div>
</div>
<div class="sect2 data-line-442">
<h3 id="common_scheduling_pitfalls">1.4. Common scheduling pitfalls</h3>
<div class="paragraph data-line-444">
<p>To avoid the most common pitfalls when scheduling tasks the system programmer should be aware that:</p>
</div>
<div class="ulist data-line-446">
<ul>
<li class="data-line-446">
<p>The scheduler behaviour is to choose the highest priority READY task to run. Always</p>
</li>
<li class="data-line-448">
<p><strong><em>IMPORTANT</em></strong>: Don&#8217;t overlook the READY state of a task. If no time slice is enabled, the only way a task will switch from <em>RUNNING</em> to <em>READY</em> is by yielding. Otherwise it can only go from <em>RUNNING</em> to <em>WAITING</em> (equivalent to) and then to <em>READY</em>.</p>
</li>
<li class="data-line-449">
<p>So with no time-slice and no blocking conditions a good practice is to <em>yield</em> or to <em>sleep</em>(1) at the end of a task loop so other tasks will have the opportunity to run.</p>
</li>
<li class="data-line-450">
<p>A time slice is not a burst. A higher priority task when ready will pause a lower priority task in the middle of its time slice, resuming from where it left.</p>
</li>
<li class="data-line-451">
<p>Make sure the number of tasks and the highest (lowest effective) assigned priority is correct in <code>kconfig.h</code>. If wrong, the scheduler might not run one or more tasks or hard fault when switching.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-453">
<h2 id="timers">2. Timers</h2>
<div class="sectionbody">
<div class="sect2 data-line-455">
<h3 id="task_delays">2.1. Task Delays</h3>
<div class="paragraph data-line-457">
<p>The primitive <code>sleep(t)</code> suspends a task on a SLEEPING state, for t ticks starting to count when called.</p>
</div>
<div class="paragraph data-line-459">
<p>For periodic activations, use <code>sleepuntil(p)</code> in which p is an absolute suspension period of time in ticks. The kernel adjusts any time drift/jitters that might happen in-between calls. If time-slice scheduler is enabled, this primitive is not available.</p>
</div>
<div class="paragraph data-line-461">
<p>To busy-wait (active delay within a task) you can use the <code>busy(t)</code> primitive.</p>
</div>
</div>
<div class="sect2 data-line-463">
<h3 id="application_timers">2.2. Application Timers</h3>
<table class="tableblock frame-all grid-all stretch data-line-466">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Time Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mode: Reload/OneShot</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callout Function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callout Arguments</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current Delta Tick</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Next Timer Address</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-476">
<p>K0 offers two types of application timers - one-shot and auto-reload. Both have the system tick as the time reference and are countdown timers.</p>
</div>
<div class="paragraph data-line-478">
<p>The system programmer needs to be aware that the callout will run within a deferred handler, that is a run-to-completion system-task.</p>
</div>
<div class="paragraph data-line-480">
<p><em>Application timer callouts cannot use blocking primitives</em>.</p>
</div>
<div class="paragraph data-line-482">
<p>One-shot timers that are within a task loop will naturally be activated periodically. A remark is that timers leverage a delta queue. Suppose you have a set of timers T1, T2, T3. They will countdown from 8, 6 and 10 ticks, respectively. For a regular queue, the node sequence is RQ = &lt;(T1, 8), (T2, 6), (T3, 10)&gt; (at tick=0). The delta queue would have pairs ordered as a sequence (tick=0): DQ = &lt;(T2, 6), (T1, 2), (T3, 2)&gt;. So having to decrease only the list head for any amount of timers, yields O(1) time-complexity within the interrupt handler.</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-485">
<h2 id="memory_allocator">3. Memory Allocator</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-488">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Memory Allocator Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associated Block Pool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of Blocks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Block Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of Free Blocks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Free Block List</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-497">
<p>Bear in mind that the standard <code>malloc()</code>  leads to fragmentation and (also, because of that) is highly undeterministic. Unless we are using it once - to allocate memory before starting up, it doesn’t fit.But often we need to 'multiplex' memory amongst tasks over time, that is to dynamic allocate and deallocate.</p>
</div>
<div class="paragraph data-line-499">
<p>To avoid fragmentation we use fixed-size memory blocks. A simple approach would be a static table marking each block either as free or taken. With this pattern you will need to 'search' for the next available block, if any - the time for searching changes - what is indeterministic.</p>
</div>
<div class="paragraph data-line-501">
<p>A suitable approach is to keep track of what is free using a linked list of addresses - a dynamic table. We use "meta-data" to initialise the linked-list - every address holds the "next" address value.</p>
</div>
<div class="paragraph data-line-503">
<p>This approach limits that the minimal size of a block is the size of a memory address - 32-bit for our supported architecture. Yet, this is the cheapest way to store meta-data. If not storing on the empty address itself, an extra 32-bit variable would be needed to each block, so it could have a size that is less than 32-bit.</p>
</div>
<div class="paragraph data-line-505">
<p>When a routine calls <code>alloc()</code> the address to be returned is the one free list is pointing to, say addr1. Before, we update free list to point to the value stored within addr1, say addr8.</p>
</div>
<div class="paragraph data-line-507">
<p>When a routine calls <code>free(addr1)</code>, we overwrite whatever has been written in addr1 with the value freelist points to (if no more <code>alloc()</code> were issued, it still is addr8), and addr1 is the freelist head again.</p>
</div>
<div class="paragraph data-line-509">
<p>A major hazard is having a routine writing to non-allocated memory within a pool, as it will spoil the meta-data.</p>
</div>
<div class="sect2 data-line-511">
<h3 id="memory_allocator_determinism">3.1. Memory Allocator Determinism</h3>
<div class="paragraph data-line-513">
<p>The memory allocator (if well employed) shall never fail, besides it might take the same amount of time to allocate and to free a block. The test below, three tasks with same priority are allocating, increasing a counter, a freeing a block of 128 bytes. If the allocator does it work at same pace every time these counters might be the same or close to.</p>
</div>
<div class="listingblock data-line-515">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"

INT stack1[STACKSIZE];
INT stack2[STACKSIZE];
INT stack3[STACKSIZE];

K_MEM bufPool;
#define BLOCK_SIZE	128
#define	N_BLOCKS	3
BYTE buf[N_BLOCKS][BLOCK_SIZE];


VOID kApplicationInit(VOID)
{
	kMemInit(&amp;bufPool, buf, BLOCK_SIZE, N_BLOCKS);
}

volatile int counter1, counter2, counter3=0;

VOID Task1(VOID)
{
	while (1)
	{
		BYTE* addr = kMemAlloc(&amp;bufPool);
		assert(addr!=NULL);
		K_ERR err = kMemFree(&amp;bufPool, addr);
		assert(err==0);
		counter1++;
		kYield();
	}
}

VOID Task2(VOID)
{
	while (1)
	{

		BYTE* addr = kMemAlloc(&amp;bufPool);
		assert(addr!=NULL);
		K_ERR err = kMemFree(&amp;bufPool, addr);
		assert(err==0);
		counter2++;
		kYield();
	}
}

VOID Task3(VOID)
{
	while (1)
	{

		BYTE* addr = kMemAlloc(&amp;bufPool);
		assert(addr!=NULL);
		K_ERR err = kMemFree(&amp;bufPool, addr);
		assert(err==0);
		counter3++;
		kYield();
	}

}</code></pre>
</div>
</div>
<div class="paragraph data-line-577">
<p>Below the results after ~2.5 million ticks of 1 ms.</p>
</div>
<div class="imageblock data-line-579">
<div class="content">
<img src="images/images/determmem.png" alt="determmem">
</div>
</div>
<hr>
</div>
</div>
</div>
<h1 id="inter_task_synchronisation_and_communication_itc" class="sect0 data-line-583"><strong>Inter-task synchronisation and communication (ITC)</strong></h1>
<div class="paragraph data-line-585">
<p>In this section a high-level description of the mechanisms used for synchronisation and communication between tasks is presented. The most part of these mechanisms are components that can be enabled/disabled and configured - exception is for <em>direct signals</em>.</p>
</div>
<div class="paragraph data-line-587">
<p>K0 handles synchronisation by events using  <em>direct signals</em>, <em>semaphores</em> and <em>event sleep/wake</em>.</p>
</div>
<div class="paragraph data-line-589">
<p><em>When feasible</em>, blocking message passing makes up an easy to follow design pattern. The idea of <em>message-as-a-signal</em> is used for <em>mailboxes</em>. As mailboxes do not use copy semantics, formally they are a shared memory protocol.</p>
</div>
<div class="paragraph data-line-591">
<p>True message passing is provided by <em>message queues</em>, which rely on copy semantics. Blocking and unblocking behaviour is avaialable for sending and receiving.</p>
</div>
<div class="paragraph data-line-593">
<p>For applications like loop controllers K0 provides <em>Cyclical Asynchronous Buffers</em>-a.k.a <em>Pump-Drop</em> messages- they compose an asynchronous one-to-many communication channel, designed to guarantee readers get the most recent produced data.</p>
</div>
<div class="sect1 data-line-595">
<h2 id="direct_signals">1. Direct Signals</h2>
<div class="sectionbody">
<div class="paragraph data-line-597">
<p>Some tasks are entirely reactive and have a single responsibility. It is cheaper and more effective to allow them to pend themselves - and be signalled without an associated kernel object - such as a semaphore. The <code>signal(id)</code> primitive takes a Task ID as a parameter. The <code>pend()</code> primitive takes no parameters, acts on the caller task. If a task is signalled when not pending, the error counter "lostSignals" is increased in its task control block. This counter is meant for some diagnostics. The standard mechanism does not check for lost signals - to catch up with. Doing so would turn it into in a (degenerated) private weak semaphore. A <em>PENDING</em> task is placed on the global sleeping queue and removed when signalled—its position in the queue does not matter.</p>
</div>
<div class="paragraph data-line-599">
<p>The main use case is for deferred handlers. The lack of a control block associated with a direct signal makes it rudimentary but sufficient, justified by the negligible cost and the ubiquity of single-purpose event-driven tasks sitting idle until notified: after readied, the scheduler will take care of its dispatching, respecting the priority. No shared resource, no contention, no priority inversion.</p>
</div>
<div class="paragraph data-line-601">
<p>A task can suspend another task using the <code>suspend(id)</code> primitive. Note that only one task can be running, so normally the target will be a task that is <code>READY</code> - it will transition to <code>SUSPENDED</code> and thus, cannot be chosen by the scheduler, until <code>signal(id)</code> happens. A task can only suspend tasks with lower priority - actually it would be severe bug to have a priority task <em>RUNNING</em> while a higher priority task is <em>READY</em>.</p>
</div>
</div>
</div>
<div class="sect1 data-line-603">
<h2 id="counter_semaphores">2. Counter Semaphores</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-605">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Semaphore Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Signed Counter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acquirer Task</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-614">
<p>K0 semaphores can be classified as 'strong counter' semaphores. Counter means the primitives <code>signal()</code> and <code>wait()</code> will increase and decrease, respectively, the initial signed value 'N' a semaphore is assigned (a semaphore cannot be initialised with a negative value).</p>
</div>
<div class="paragraph data-line-616">
<p>When <code>wait()</code> results in a negative value, the caller will be blocked within the semaphore queue. The negative value of a counter semaphore inform us straight away how many tasks are blocked waiting for a signal.</p>
</div>
<div class="paragraph data-line-618">
<p>When signalled only one task is unblocked. If a semaphore has a dedicated queue it is 'strong', because it establishes an order. Not having a queue makes a 'weak' semaphore, as the task to be released depends on the position of the task who signals.</p>
</div>
<div class="paragraph data-line-620">
<p>For a section guarded by a semaphore, many tasks can be active. The owner of a guarded region is defined as the highest priority task able to pass a <code>wait()</code>. When a task blocks on a semaphore, if its priority is higher than the owner&#8217;s priority the blocked task propagates its priority to the owner, as a means to diminish the priority inversion time. When a task <code>signal()</code> a semaphore (after a <code>wait()</code>), it is leaving the guarded region so its priority is restored.</p>
</div>
<div class="paragraph data-line-622">
<p>The queue discipline for a semaphore can be configured either as FIFO or priority-based - the former being the default.</p>
</div>
</div>
</div>
<div class="sect1 data-line-625">
<h2 id="mutex_semaphores">3. Mutex Semaphores</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-627">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mutex Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Locked state</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-635">
<p>A mutex is a semaphore specialisation. They lock a critical section under strict ownership: only the task that owns a mutex can act on it again.
If a task that is not an owner tries to lock a mutex, the task switches to a <code>BLOCKED</code> state, until the mutex is unlocked. When a non-owner tries to unlock a mutex, the behaviour is implementation-defined. As it can only mean a programming mistake or a serious system bug, in K0 it will hard fault.</p>
</div>
<div class="paragraph data-line-638">
<p>Note that, although K0 provides mutex as a distinct mechanism, "1"-semaphores can provide the same mutual exclusive behaviour, handling priority inversion with the same efficiency - although not providing strict ownership.</p>
</div>
</div>
</div>
<div class="sect1 data-line-640">
<h2 id="events_sleepwake">4. Events (Sleep/Wake)</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-642">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Event Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event ID (self-assigned)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sleeping Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-649">
<p>An event is a condition in time that will trigger a reaction: a countdown timer reaching zero, or the 7th bit of the 7th received stream on the 7th pin in the 7th fullmoon night in the 7th year of system uptime - being 0. These are 2 events. The reactions we don’t bother, it can even be 'to ignore the event'.</p>
</div>
<div class="paragraph data-line-651">
<p>Events are <em>pure signals</em>, they are absent or present: we don&#8217;t have the notion of time duration for an event.
A counter semaphore is an event recorder - and as it needs to count every <code>signal()</code> operation needs to be mapped to a single <code>wait()</code> operation - thus <em>semaphore signals do not broadcast</em>. The ability to broadcast the occurrence of an event is paramount on reactive systems.</p>
</div>
<div class="paragraph data-line-654">
<p>Say a modern car has its speed increased by the driver. Different groups of mechanisms need to be notified to take some action. The radio so that it might boost the volume. The windshield wiper control will increase its speed. The cruiser will switch off - as it might indicate a need for the driver to regain control, and I’d bet the cruiser switches off before the radio volume is boosted.</p>
</div>
<div class="paragraph data-line-656">
<p>So, tasks <code>sleep(event)</code> for an event. They rely on another task/ISR to trigger a <code>wake(event)</code> that will <code>READY</code> <em>all tasks sleeping on that event at once</em>. What happens later, is up to the scheduler and the application design. The primitive <code>signal(event)</code> unblocks a single task from the event queue.</p>
</div>
<div class="paragraph data-line-658">
<p>Within K0BA, an event is associated to a kernel object. The kernel assigns only an ID and a sleeping queue within an' event' object. The associated sleeping queue is used to diminish the overhead of the <code>wake()</code> primitive - with a global queue the kernel would need to check if the task is sleeping on a specific event.
Combining events with mutexes is a means of creating <em>Condition Variables</em> and <em>Monitors</em>.</p>
</div>
</div>
</div>
<div class="sect1 data-line-663">
<h2 id="remarks_on_synchronisation_services">5. Remarks on synchronisation services</h2>
<div class="sectionbody">
<div class="sect2 data-line-665">
<h3 id="installed_callbacks_for_signals">5.1. Installed callbacks for signals</h3>
<div class="paragraph data-line-666">
<p>It is tempting to become UNIX-minded and install callbacks on signals associated to a task. When resuming, a task first checks for any pending signals. If they exist, the task deviates from its normal flow (as within any software interrupt), runs the callback, and deals with any side effects. The overhead is excessive—both in time and space—a need to reserve a space on the stack or provide a stack for the callback; a need to tune the context-switching to happen when there is a signal pending and to get back to the deviated point. Yet the main reason for the choosing to not implement signals as described is that it hinders determinism.</p>
</div>
</div>
<div class="sect2 data-line-668">
<h3 id="time_out_on_blocking_primitives">5.2. Time-out on blocking primitives</h3>
<div class="paragraph data-line-669">
<p>Blocking primitives within K0BA have a timeout parameter, given in ticks. Only kPend() does not given its logical simplistic nature, and application. If the task cannot perform access to a resource within a time given in system ticks, it will switch back to READY, eventually be dispatched, and force a return K_ERR_TIMEOUT. Note that a 0 for time-out is the same as the <code>K_WAIT_FOREVER</code>. Non-blocking primitives are not mixed with blocking primitives.</p>
</div>
</div>
<div class="sect2 data-line-671">
<h3 id="event_groups_multi_condition_synchronisation">5.3. Event Groups (multi-condition synchronisation)</h3>
<div class="paragraph data-line-673">
<p>As on VER0.3.1 the decision is not to provide event groups as another abstraction. The ways to leverage multicondition synchronisation are too many, there is no 'enough' abstraction. The current mechanisms when combined can provide multicondition synchronisation in the form of Monitors, Condition Variables, Event Groups and Flags, etc., as demonstrated on the usage patterns at the end of this document.</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-675">
<h2 id="mailbox">6. Mailbox</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-678">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mailbox Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mailbox status</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner task</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-687">
<p>While in GPOS jargon mailboxes are queues of messages - as a distinction from pipes (that are stream buffers) - in embedded system software, often mailboxes are said to have a capacity of a a single messsage, and more recently you will not find it as a distinct mechanism - you use a 1-message queue.</p>
</div>
<div class="paragraph data-line-689">
<p>In K0BA a mailbox is a message-as-signal mechanism. Strictly it is not a message passing - it is a shared memory protocol. The mail passed is the address of an object that contains a message - there is no copy. This object is application-dependent, so sender and receiver must agree on the concrete type and mantain the message scope.</p>
</div>
<div class="paragraph data-line-691">
<p>Mailboxes can initialise full/empty, have their own waiting queue and handle priority propagation - when passing a token/message between tasks, they synchronise on a turnstile - what is a handy use for them.</p>
</div>
<div class="paragraph data-line-693">
<p>A mailbox interface contract can be defined as follows:</p>
</div>
<div class="olist arabic data-line-695">
<ol class="arabic">
<li class="data-line-695">
<p>A mailbox starts either EMPTY or FULL.</p>
</li>
<li class="data-line-697">
<p>If starting FULL, it is initialised with an address.</p>
</li>
<li class="data-line-699">
<p>A mailbox will always have an assigned 'owner' after the first send() or recv() primitive. The owner is the task who succeded gaining access to the box.</p>
</li>
<li class="data-line-701">
<p>When a producer <code>post()</code>  to a FULL mailbox, it is enqueued on the mailbox waiting queue, and its task will now be on state SENDING.</p>
</li>
<li class="data-line-703">
<p>Likewise, a consumer blocks when issuing a <code>pend()</code> on an empty mailbox. Task status switches to RECEIVING and it is enqueued on the mailbox waiting queue.</p>
</li>
<li class="data-line-705">
<p>A mailbox implements a priority propagation protocol, boosting the owner priority on the occasion a higher priority task blocks waiting.</p>
</li>
<li class="data-line-707">
<p>The waiting queue for a mailbox, has a discipline that can either be priority or FIFO. Default is by priority, to be coherent with the scheduler.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-709">
<p>You need to be aware of how the priority of tasks and mailbox queue discipline impact the message exchange, and therefore the program flow. Say you have a bad idea: two producers and a consumer with priorities High, Medium and Low, respectively. Producers <code>post()</code> and consumers <code>pend()</code> - no other blocking conditions. If the queue discipline for the mailbox is ordered by priority, the medium priority producer will block once and deadlock - since when the consumer empties the box, who is released is the higher priority - always. If it is a FIFO, it will receive the two messages serially - if you configure as FIFO, mind you are choosing to delay a higher priority task.</p>
</div>
<div class="sect2 data-line-711">
<h3 id="sending_receiving">6.1. Sending-receiving</h3>
<div class="paragraph data-line-713">
<p>The optional <code>postpend()</code> primitive sends a message and waits for a reply - its straight for any synchronous client-server communication - a client sends a request and wait for answer.</p>
</div>
</div>
<div class="sect2 data-line-715">
<h3 id="asynchronous_mailboxes_methods">6.2. Asynchronous mailboxes methods</h3>
<div class="paragraph data-line-716">
<p>As an extension for the same synchronous mailboxes there are primitives asend() and arecv(). Instead of blocking they will return an error.</p>
</div>
<div class="paragraph data-line-718">
<p>There two other asynchronous methods: <code>asendovw()</code>  - to deposit a message on a mailbox even if it is FULL, and <code>arecvkeep()</code> - to retrieve a message from a mailbox but the box will not switch to EMPTY - so other receivers can grab the same message.</p>
</div>
<div class="admonitionblock note data-line-721">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-722">
<p>There are many ways to ensure the contents of a mailbox are not changed before the consumer has the chance to read it. One is using the memory allocator and pair each <code>post()</code> with an <code>alloc()</code> and each <code>pend()</code> with a <code>free()</code>. You might use a ring buffer. You can check if the mailbox is full before before posting and then choose to reuse an address or not.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-725">
<h2 id="message_queue">7. Message Queue</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-727">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Message Queue Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Storage address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write Index</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read Index</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max of Messages</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner task</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-739">
<p>As mentioned, Mailboxes and Message Queues are quite distinct not because of the message size. A queue is indeed a message passing mechanism, taking full data ownership - it is a data-centric mechanism.</p>
</div>
<div class="paragraph data-line-741">
<p>For a message queue, user will provide a buffer with enough capacity (number of messages x message size), that will be handled as a circular buffer. Message queues always start empty and they pass by copy.</p>
</div>
<div class="paragraph data-line-743">
<p>The primitives for the message queue are send(), recv(), asend(), arecv(),jam() and peek(). Opposed to mailboxes which asynchronous methods are an extension, queues can be configured as either synchronous, asynchronous or both.</p>
</div>
<div class="paragraph data-line-745">
<p>Message Queues also propagate priority when blocking, and the blocking queue discipline is configured either as by priority or FIFO. This is not to be confused with the message buffering, the first message placed is the first extracted - except for the jam() that places a messages on the queue front. But who sends/receives a message is a matter of task precedence when accessing a queue.</p>
</div>
<div class="paragraph data-line-747">
<p>Note, a queue will behave asynchronously until a recv() is issued to an empty queue and when a send() is issued on a full queue. A task that blocks on a full queue will be released as soon as a reader extracts a message and vice-versa.</p>
</div>
<div class="paragraph data-line-749">
<p>This behaviour might be desirable or not. The result, anyway, is that tasks with different periods end up synchronising to the lowest rate - (usually, undesirable for real-time). After a queue blocks full, when it eventually unblocks you might had lost data - after all, a producer when blocked won’t be able to update its data. Is it the problem? Yes and no. The problem with a blocking queue is that by buffering you are reading from the past.</p>
</div>
<div class="paragraph data-line-751">
<p>Between a message that does not arrive, and one that arrives with information that is not useful, there is no practical difference. But if a message arrives with information that will deceive your control loop to perform a wrong action - this is the worse.</p>
</div>
<div class="admonitionblock note data-line-754">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-755">
<p>If you need a mailbox behaviour with copy semantics, (maybe) you are fine using a 1-message queue - note though, a deepy copy is slow: a 4-byte single-message queue is around 6.5 times slower than a mailbox. You can pass pointers through the message queue if having too long messages - still they will be a copy of addresses (4-byte messages).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-759">
<h2 id="pump_drop_messages">8. Pump-Drop Messages</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all stretch data-line-762">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pump-Drop Pool Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allocator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Most Recent Buffer Address</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch data-line-769">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pump-Drop Buffer Record</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Readers Count</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-776">
<p>Pump-Drop Buffers are meant to overcome the drawbacks exposed above for message queues, based on the concept of Cyclical Asynchronous Buffers (CAB) (essentialy as found in the HARTIK kernel). This is a fully asynchronous, one-to-many mechanism, that has an implicit memory allocator for the PD-Buffers.</p>
</div>
<div class="paragraph data-line-778">
<p>Primitives for Pump-Drop buffers (PDB) are:</p>
</div>
<div class="ulist data-line-780">
<ul>
<li class="data-line-780">
<p>For writer: reserve() and pump() .</p>
</li>
<li class="data-line-782">
<p>For readers: fetch() and drop().</p>
</li>
</ul>
</div>
<div class="paragraph data-line-784">
<p>The semantics is as follows - remember it is one writer to many readers:</p>
</div>
<div class="olist arabic data-line-786">
<ol class="arabic">
<li class="data-line-786">
<p>When the producer needs to write a new message, first it reserves a PD-buffer. This might already be allocated - if it is allocated but has readers, a new PD-buffer is allocated, to ensure data consistency.</p>
</li>
<li class="data-line-788">
<p>Writer now appends a message to be sent (application-dependent) and <em>pump</em> the buffer.</p>
</li>
<li class="data-line-790">
<p>After pumped, the PD buffer is marked as the current buffer. From now on, the former pumped PDB cannot be fetched and will eventually drop to 0 readers.</p>
</li>
<li class="data-line-792">
<p>A reader first 'fetches' a PDB. A non-null return for a fetch will increase the readers count on the PDB.</p>
</li>
<li class="data-line-794">
<p>After 'having' the message, a reader 'drops the PD-buffer': the kernel checks if it was the last reader and it is not the current PDB - if these two conditions are met, the buffer is deallocated. (Checking it is NOT the current PDB guarantees there is already a new PDB in the circuit so readers won&#8217;t starve).</p>
</li>
</ol>
</div>
<div class="paragraph data-line-796">
<p>This mechanism guarantees the information is always updated, but no message is corrupted. The ideal pool size, thus, is simply the number of tasks + 1.</p>
</div>
<hr>
</div>
</div>
<h1 id="usage_patterns" class="sect0 data-line-800"><strong>Usage Patterns</strong></h1>
<div class="paragraph data-line-802">
<p>In this section some simple usage patterns are being attached. The board used to run these snippets is a Nucleo-F103RB (ARM Cortex-M3 based).</p>
</div>
<div class="sect1 data-line-804">
<h2 id="monitor_0_barrier">1. Monitor #0 (Barrier)</h2>
<div class="sectionbody">
<div class="paragraph data-line-806">
<p>Usage: resource access/tasks coordination</p>
</div>
<div class="listingblock data-line-808">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"

K_EVENT syncEvent; /* state event				    */
UINT32 syncCounter; /* state representation        */
K_MUTEX syncMutex; /* monitor lock				    */
K_MUTEX resourceLock; /* if there is a resource */
#define SYNC_CONDITION (syncCounter&gt;=3) /* needed tasks in the barrier */


VOID kApplicationInit(VOID)
{
	kMutexInit(&amp;syncMutex);
	kEventInit(&amp;syncEvent);
	kMutexInit(&amp;resourceLock);
	syncCounter = 0;
}


/* only one task can be active within a monitor
 they are enqueued either on the mutex or on the event
 */
static VOID synch(VOID)
{

	kMutexLock(&amp;syncMutex, K_WAIT_FOREVER);
	kprintf("Task %d  entered monitor...\n\r", K_RUNNING_TID);
	syncCounter += 1;
	if (!(SYNC_CONDITION))
	{
		kMutexUnlock(&amp;syncMutex);

		kEventSleep(&amp;syncEvent, K_WAIT_FOREVER);
		kMutexLock(&amp;resourceLock, K_WAIT_FOREVER);
		kprintf("Task %d is active in the monitor...\n\r", K_RUNNING_TID);
		kMutexUnlock(&amp;resourceLock);
	}
	else
	{
		syncCounter = 0;
		kprintf("Task %d frees the waiting queue. \n\r", K_RUNNING_TID);
		kEventWake(&amp;syncEvent);
		kMutexUnlock(&amp;syncMutex);

	}
	kprintf("Task %d leaves monitor...\n\r", K_RUNNING_TID);
}

VOID Task1(VOID)
{

	while (1)
	{
		kSleep(5);
		synch();
	}
}

VOID Task2(VOID)
{
	while (1)
	{
		kSleep(8);
		synch();
	}
}

VOID Task3(VOID)
{
	while (1)
	{
		kSleep(3);
		synch();
	}

}</code></pre>
</div>
</div>
<div class="imageblock data-line-887">
<div class="content">
<img src="images/images/syncbarr.png" alt="syncbarr">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-889">
<h2 id="monitor_1_turnstile">2. Monitor #1 (Turnstile)</h2>
<div class="sectionbody">
<div class="paragraph data-line-891">
<p>In this variation we use mailboxes for turnstile. Also the task that wakes up all others will use the resource within the monitor (be active).</p>
</div>
<div class="listingblock data-line-893">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">K_EVENT syncEvent; /* state event				    */
UINT32 syncCounter; /* state representation        */
K_MBOX syncMbox;
K_MBOX resourceMbox;
/* keys */
UINT32 mayEnter = 0xAABBCCDD;
UINT32 mayAcquire = 0xBBCCDDEE;
UINT32 *acqPtr;
UINT32 *enterPtr;

#define SYNC_CONDITION (syncCounter&gt;=3) /* needed tasks in the barrier */

VOID kApplicationInit(VOID)
{
	kEventInit(&amp;syncEvent);
	kMboxInit(&amp;resourceMbox, &amp;mayAcquire);
	kMboxInit(&amp;syncMbox, &amp;mayEnter);

	syncCounter = 0;
}

static VOID synch(VOID)
{
	kMboxPend(&amp;syncMbox, (ADDR*) &amp;enterPtr, K_WAIT_FOREVER);
	syncCounter += 1;
	if (!(SYNC_CONDITION))
	{
		kMboxPost(&amp;syncMbox, &amp;mayEnter, K_WAIT_FOREVER);
		kEventSleep(&amp;syncEvent, K_WAIT_FOREVER);
		goto ACTIVE;
	}
	syncCounter = 0;
	kEventWake(&amp;syncEvent);
	kMboxPost(&amp;syncMbox, &amp;mayEnter, K_WAIT_FOREVER);
	ACTIVE:
	kMboxPend(&amp;resourceMbox, (ADDR*) &amp;acqPtr, K_WAIT_FOREVER);
	kprintf("Task %d is active in the monitor...\n\r", K_RUNNING_TID);
	kMboxPost(&amp;resourceMbox, &amp;mayAcquire, K_WAIT_FOREVER);

}

VOID Task1(VOID)
{

	while (1)
	{
		kSleep(5);
		synch();
	}
}

VOID Task2(VOID)
{
	while (1)
	{
		kSleep(8);
		synch();
	}
}

VOID Task3(VOID)
{
	while (1)
	{
		kSleep(3);
		synch();
	}

}</code></pre>
</div>
</div>
<div class="imageblock data-line-967">
<div class="content">
<img src="images/images/mboxturnstiles.png" alt="mboxturnstiles">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-970">
<h2 id="multi_condition_notification_0">3. Multi-condition Notification #0</h2>
<div class="sectionbody">
<div class="paragraph data-line-971">
<p>Usage: coordinate a notified task action on a combination of events</p>
</div>
<div class="listingblock data-line-975">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* @file application.c */

#include "application.h"

/* waiting 4 flags to be active before going */

INT stack1[STACKSIZE];
INT stack2[STACKSIZE];
INT stack3[STACKSIZE];

typedef enum
{
	TEMPERATURE = 1, HUMIDITY, CO2, FLOW
} UPDATE_t;

#define FLAG_TEMP_SENSOR_UPDATE   (1U &lt;&lt; 0)
#define FLAG_HUM_SENSOR_UPDATE    (1U &lt;&lt; 1)
#define FLAG_CO2_SENSOR_UPDATE    (1U &lt;&lt; 2)
#define FLAG_FLOW_SENSOR_UPDATE   (1U &lt;&lt; 3)

K_MBOX mbox;

/*** Init kernel objects here */
VOID kApplicationInit(VOID)
{
	kMboxInit(&amp;mbox, NULL);
}

/* this task notifies which sensors had been updated */
VOID NotifyTask(VOID)
{
	UINT32 sendFlag = 0;
	UPDATE_t updateType = 0;

	while (1)
	{   /* simple sum to switch sensor type */

			updateType = (updateType + 1);
			if (updateType &gt; 4)
			{
				updateType = 1;
			}
			switch (updateType)
			{
			case (TEMPERATURE):
				sendFlag = FLAG_TEMP_SENSOR_UPDATE;
				break;
			case (HUMIDITY):
				sendFlag = FLAG_HUM_SENSOR_UPDATE;
				break;
			case (CO2):
				sendFlag = FLAG_CO2_SENSOR_UPDATE;
				break;
			case (FLOW):
				sendFlag = FLAG_FLOW_SENSOR_UPDATE;
				break;
			default:
				break;
			}
			K_ERR err = kMboxPost(&amp;mbox, (ADDR) &amp;sendFlag, K_WAIT_FOREVER);
			kSleepUntil(2); /* every 10ms */
		}
}

/* this task stores events by OR'ing. when it matches the expected event record it expects to take an action, the storage is reset.
alternatively it could take an action whenever a single flag was active */

VOID NotifiedTask(VOID)
{
	UINT32 *rcvdFlag = 0;
	UINT32 wantedFlags = FLAG_TEMP_SENSOR_UPDATE | FLAG_HUM_SENSOR_UPDATE |
	FLAG_CO2_SENSOR_UPDATE |
	FLAG_FLOW_SENSOR_UPDATE;
	UINT32 rcvdFlags = 0;
	while (1)
	{
		K_ERR err = kMboxPend(&amp;mbox, (ADDR) &amp;rcvdFlag, K_WAIT_FOREVER);
		if (err == 0)
		{
			rcvdFlags |= *rcvdFlag;
			if (rcvdFlags == wantedFlags)
			{
				rcvdFlags = 0; /* clear rcvd flags */
				kprintf("Task synchronized\n\r");
					/* do work */
			}
			else
			{
				kprintf("Still missing a flag\n\r");
			}
		}
	}
}


VOID Task3(VOID)
{
	while (1)
	{
		kSleep(1);

	}

}</code></pre>
</div>
</div>
<div class="imageblock data-line-1081">
<div class="content">
<img src="images/images/mboxflags.png" alt="mboxflags">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1084">
<h2 id="multi_condition_notification_1">4. Multi-condition Notification #1</h2>
<div class="sectionbody">
<div class="paragraph data-line-1085">
<p>Usage: multi-condition broadcast, notification, observer pattern</p>
</div>
<div class="paragraph data-line-1087">
<p>Event groups and event flags - with <code>set(flags)</code>,  <code>wait(flags, ALL/ANY)</code> and <code>clear(flags)</code>.
This approach use sleep/wake associated to an integer - and handles pretty much everything that could be shipped as another kernel service.</p>
</div>
<div class="listingblock data-line-1091">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

INT stack1[STACKSIZE];
INT stack2[STACKSIZE];
INT stack3[STACKSIZE];
INT stack4[STACKSIZE];

#define MAX_FLAGS 32
#define FLAG_1 (1U &lt;&lt; 0) /* subject 1 */
#define FLAG_2 (1U &lt;&lt; 1) /* subject 2 */
#define FLAG_3 (1U &lt;&lt; 2) /* subject 3 */

K_EVENT eventGroup;
K_MUTEX flagMutex; /* lock for protecting the flag variable */
static volatile UINT32 eventFlags = 0U; /*  event state representation */

VOID kApplicationInit(VOID)
{
	kEventInit(&amp;eventGroup);
	kMutexInit(&amp;flagMutex);
}

/* set flags (publish/notify) */
VOID setEventFlags(UINT32 flagMask)
{
	kMutexLock(&amp;flagMutex, K_WAIT_FOREVER);
	eventFlags |= flagMask;
	kMutexUnlock(&amp;flagMutex);

	kEventWake(&amp;eventGroup);
}

/* subscribe/observe */
VOID waitForEventFlags(UINT32 flagMask, BOOL all) /* ALL or ANY */
{
		/*go to sleep */
		SLEEP:
		kEventSleep(&amp;eventGroup, K_WAIT_FOREVER);

		/* a taks wakes here  */
        /* CR: either use a mutex or a disable all irqs (preferable) */
		kMutexLock(&amp;flagMutex, K_WAIT_FOREVER);
		UINT32 currentFlags = eventFlags; /* temp copy */
		/* check */
		if ((all &amp;&amp; ((currentFlags &amp; flagMask) == flagMask)) || /* all flags */
		(!all &amp;&amp; (currentFlags &amp; flagMask))) /* any flags */
		{
			kMutexUnlock(&amp;flagMutex);
			return; /* good to go */
		}
		kMutexUnlock(&amp;flagMutex); /* nope, get back sleeping */
	    goto SLEEP;
}

VOID clearEventFlags(UINT32 flagMask)
{
	kMutexLock(&amp;flagMutex, K_WAIT_FOREVER);
	eventFlags &amp;= ~flagMask;
	kMutexUnlock(&amp;flagMutex);
}

VOID Task1(VOID) /* the setter, highest priority task  */
{
	while (1)
	{
		kSleep(1);
		setEventFlags(FLAG_1);
		setEventFlags(FLAG_2);
		kSleep(20);
		setEventFlags(FLAG_3);
	}
}

VOID Task2(VOID) /* waits for all flags */
{

	while (1)
	{
		waitForEventFlags(FLAG_1 | FLAG_2 | FLAG_3, TRUE); /* all flags */
		/* callback(); */
		kprintf("T2: got all flags \n\r");
		clearEventFlags(FLAG_1 | FLAG_2 | FLAG_3); /*clear*/
	}
}

VOID Task3(VOID) /* waits for any flags */
{
	while (1)
	{
		waitForEventFlags(FLAG_1 | FLAG_2, FALSE);
		/* callback(FLAG_1); or callback(FLAG_2); */
		kprintf("T3: At least one flag is set!\n\r");
		clearEventFlags(FLAG_1 | FLAG_2);
	}
}


VOID Task4(VOID) /* just want flag 3*/
{
	while (1)
	{
		waitForEventFlags(FLAG_3, TRUE);
		/* callback(); */
		kprintf("T4: FLAG_3 is up!\n\r");
		clearEventFlags(FLAG_3);
	}

}</code></pre>
</div>
</div>
<div class="imageblock data-line-1206">
<div class="content">
<img src="images/images/eventflags.png" alt="eventflags">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1209">
<h2 id="extended_rendez_vous_0">5. Extended rendez-vous #0</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1 data-line-1213">
<h2 id="extended_rendez_vous_1">6. Extended rendez-vous #1</h2>
<div class="sectionbody">
<div class="paragraph data-line-1215">
<p>Usage: Many-to-one command-response</p>
</div>
<div class="listingblock data-line-1217">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"


#define MAX_PAYLOAD 36

K_MBOX serverMbox;
K_MBOX clientMbox1;
K_MBOX clientMbox2;

/* Application Protocol Data Unit */
typedef struct
{
	BYTE length; /* Length of the APDU payload */
	BYTE payload[MAX_PAYLOAD]; /* APDU payload */
	K_MBOX *replyMbox; /* Pointer to the client's reply mailbox */
} APDU;


void kApplicationInit(VOID)
{
	kMboxInit(&amp;serverMbox, NULL);
	kMboxInit(&amp;clientMbox1,NULL);
	kMboxInit(&amp;clientMbox2,NULL);
}

/* Hello-server */
VOID Server(VOID)
{
	APDU *request, response;

	while (1)
	{
		/* Wait for a request */
		if (kMboxPend(&amp;serverMbox, &amp;request, NULL, K_WAIT_FOREVER) == K_SUCCESS)
		{
			kprintf("Server received request: %s\n\r", request-&gt;payload);

			/* Process the request */
			response.length = snprintf((char*) response.payload,
					sizeof(response.payload), "Response to: %s",
					request-&gt;payload);

			/* Send the response back to the client's reply mailbox */
			if (kMboxPost(request-&gt;replyMbox, &amp;response, K_WAIT_FOREVER) != K_SUCCESS)
			{
				kprintf("ACK fail\n\r");
			}
		}
	}
}

/* Hello-clients */
/
VOID Client1(VOID)
{
	APDU request, *response;

	while (1)
	{
		/* Prepare the request */
		snprintf((char*) request.payload, sizeof(request.payload),
				"Hello from Client 1");
		request.length = strlen((char*) request.payload);
		request.replyMbox = &amp;clientMbox1; /* Specify the reply mailbox */

		/* Send the request to the server */
		if (kMboxPost(&amp;serverMbox, &amp;request, K_WAIT_FOREVER) == K_SUCCESS)
		{

			/* Wait for the response */
			if (kMboxPend(&amp;clientMbox1, (ADDR*)&amp;response, K_WAIT_FOREVER)
					== K_SUCCESS)
			{
				kprintf("C1 ACK'ed %s\n\r", response-&gt;payload);
			}
			else
			{
				kprintf("1F\n\r");
			}
		}
		else
		{
			kprintf("1F\n\r");
		}
	}
	kSleepUntil(10); /* every 50ms */
}

VOID Client2(VOID)
{
	APDU request, *response;

	while (1)
	{
		/* Prepare the request */
		snprintf((char*) request.payload, sizeof(request.payload),
				"Hello from Client 2");
		request.length = strlen((char*) request.payload);
		request.replyMbox = &amp;clientMbox2; /* Specify the reply mailbox */

		/* Send the request to the server */
		if (kMboxPost(&amp;serverMbox, &amp;request, K_WAIT_FOREVER) == K_SUCCESS)
		{

			/* Wait for the response */
			if (kMboxPend(&amp;clientMbox2, (ADDR*)&amp;response, K_WAIT_FOREVER)
					== K_SUCCESS)
			{
				kprintf("C2 ACK'ed: %s\n\r", response-&gt;payload);
			}
			else
			{
				kprintf("2FAIL\n\r");
			}
		}
		else
		{
			kprintf("2FAIL\n\r");
		}

	}
	kSleep(10); /* 50ms */
}</code></pre>
</div>
</div>
<div class="imageblock data-line-1344">
<div class="content">
<img src="images/images/multiclient.png" alt="multiclient">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1346">
<h2 id="extended_rendez_vous_2">7. Extended rendez-vous #2</h2>
<div class="sectionbody">
<div class="paragraph data-line-1348">
<p>Usage: client-server communication</p>
</div>
<div class="listingblock data-line-1350">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* our server performs arithmetic operations. very useful... */

typedef enum
{
	ADD, SUB, MULT

} OP_ID_t;

struct request
{
	OP_ID_t opcode;
	INT parm1;
	INT parm2;

};

typedef struct request REQ_t;

K_MBOX mbox;

VOID kApplicationInit(VOID)
{

	kMboxInit(&amp;mbox, NULL);
}

VOID Task1(VOID)
{

	REQ_t req;
	INT *resultPtr;
	req.opcode = 0;

	while (1)
	{
		req.parm1 = 1531;
		req.parm2 = 33;
		kprintf("Requesting server ... -&gt;\n\r");
		kMboxPostRecv(&amp;mbox, &amp;req, (ADDR*)&amp;resultPtr, K_WAIT_FOREVER);
		kprintf("-&gt; The result is %d\n\r", (INT)*resultPtr);
		req.opcode++;
		if (req.opcode &gt; 2)
			req.opcode = ADD;
	}
}

VOID Task2(VOID)
{
	REQ_t *clientReq;
	while (1)
	{
		kMboxPend(&amp;mbox, (ADDR*)&amp;clientReq, K_WAIT_FOREVER);
		INT parm1 = clientReq-&gt;parm1;
		INT parm2 = clientReq-&gt;parm2;
		INT result = 0;
		kprintf("Recv client request &lt;-\n\r");
		switch (clientReq-&gt;opcode)
		{
		case (ADD):
			kprintf("Adding...\n\r");
			result = parm1 + parm2;
			break;
		case (SUB):
			kprintf("Subtracting...\n\r");
			result = parm1 - parm2;
			break;
		case (MULT):
			kprintf("Multiplying...\n\r");

			result = parm1 * parm2;
			break;
		default:
			kprintf("Unknown...\n\r");

			break;

		}
		kprintf("&lt;- Sending response..\n\r");
		kMboxPost(&amp;mbox, &amp;result, 0);

	}
}</code></pre>
</div>
</div>
<div class="imageblock data-line-1437">
<div class="content">
<img src="images/images/sendrecv.png" alt="sendrecv">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1439">
<h2 id="queueing_pattern_0">8. Queueing Pattern #0</h2>
<div class="sectionbody">
<div class="paragraph data-line-1441">
<p>Usage: Asynch (like) comm, serialising access, logging, monitoring</p>
</div>
<div class="listingblock data-line-1444">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

INT stack1[STACKSIZE];
INT stack2[STACKSIZE];

/* sensor types */
typedef enum
{
	TEMPERATURE = 0, HUMIDITY, CO2, FLOW
} SensorType_t;

/* message sent through the queue */
typedef struct sensorMsg
{
	SensorType_t sensorType;
	INT32 sensorValue;
} Mesg_t;

#define N_MESSAGE 10
#define MESSAGE_SIZE sizeof(Mesg_t)

K_MESGQ mesgQueue;

BYTE queueBuffer[N_MESSAGE * MESSAGE_SIZE];

VOID kApplicationInit(VOID)
{
	kMesgQInit(&amp;mesgQueue, (ADDR) queueBuffer, MESSAGE_SIZE, N_MESSAGE);
}

VOID SensorRead(VOID)
{
	SensorType_t sensorType = 0;
	Mesg_t msg;
	while (1)
	{
		sensorType = rand() % 4;
		switch (sensorType)
		{
		case (TEMPERATURE):

			msg.sensorValue = rand() % 50;
			msg.sensorType = TEMPERATURE;
			break;
		case (HUMIDITY):
			msg.sensorValue = rand() % 100;
			msg.sensorType = HUMIDITY;
			break;
		case (CO2):
			msg.sensorValue = rand() % 1000;
			msg.sensorType = CO2;
			break;
		case (FLOW):
			msg.sensorValue = rand() % 10;
			msg.sensorType = FLOW;
			break;
		default:
			break;
		}
		kMesgQSend(&amp;mesgQueue, &amp;msg, K_WAIT_FOREVER);
        kSleepUntil(2); /* every 10ms */
	}
}

VOID SensorLogging(VOID)
{
	Mesg_t recvMesg;
	while (1)
	{
	    kMesgQRecv(&amp;mesgQueue, &amp;recvMesg, K_WAIT_FOREVER);
		{
        /* pretend printf is the logging method */
			if (recvMesg.sensorType == TEMPERATURE)
				kprintf("Temperature Sensor update: %lu C\n\r",
						recvMesg.sensorValue);
			if (recvMesg.sensorType == HUMIDITY)
				kprintf("Humidity Sensor update: %lu%% \n\r",
						recvMesg.sensorValue);
			if (recvMesg.sensorType == CO2)
				kprintf("CO2 Sensor update: %lu ppm\n\r", recvMesg.sensorValue);
			if (recvMesg.sensorType == FLOW)
				kprintf("FLOW Sensor update: %lu liters/min\n\r", recvMesg.sensorValue);

		}
	}
}


/* why enqueue and not log when reading? to not loose track, events are buffered and log happens on another task */</code></pre>
</div>
</div>
<div class="imageblock data-line-1539">
<div class="content">
<img src="images/images/queuing.png" alt="queuing">
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1542">
<h2 id="queueing_pattern_1_active_object">9. Queueing Pattern #1 (Active Object)</h2>
<div class="sectionbody">
<div class="paragraph data-line-1544">
<p>In this pattern tasks are split in <em>AcquisitionTask</em> (medium priority, periodic), <em>ActuatorTask</em> (low priority, periodic) and <em>AlarmsTask</em> (higher priority, blocking receiver, run-to-completion).</p>
</div>
<div class="paragraph data-line-1546">
<p>The acquisition task will pump messages to a pump-drop queue.
These messages are active objects, in the sense they carry a callback and arguments to be executed by the receiver.
When values of a sensor are deemed critical the higher priority task will be signalled, will fetch a message and <em>run-to-completion</em> accordingly.</p>
</div>
<hr>
</div>
</div>
<h1 id="the_road_ahead" class="sect0 data-line-1551">The road ahead</h1>
<div class="paragraph data-line-1553">
<p>What we got right?
- simple and efficient RMS
-</p>
</div>
<div class="paragraph data-line-1558">
<p><a href="mailto:tony@kernel0.org">tony@kernel0.org</a></p>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>
